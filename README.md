# [校园导航程序]

## 一、项目简介
本项目旨在通过多种算法的综合运用，解决路径规划相关的问题，包括单源路径搜索、多源判断、所有可行路径的获取以及特定条件下（如不经过某些节点）的路径优化等功能。同时引入字典树数据结构，以提升某些操作的效率。

## 二、核心算法及思路

### 1. 单源路径搜索（使用 jk 算法）
使用 jk 算法（假设是某种特定的单源最短路径算法，如 Dijkstra 或 Bellman-Ford 等，这里以 jk 代称）来计算从一个源节点到其他所有节点的最短路径。算法的核心步骤如下：
1. 初始化源节点的距离为 0，其他节点的距离为无穷大。
2. 不断从未访问的节点中选择距离最小的节点，更新其邻居节点的距离。
3. 重复步骤 2，直到所有节点都被访问过或无法再更新距离为止。

### 2. 多源判断（使用并查集）
利用并查集数据结构来判断是否存在多源情况。并查集的主要操作包括：
1. 初始化每个节点为一个独立的集合。
2. 当发现两个节点之间存在某种连接关系（例如边的存在）时，将它们所属的集合合并。
3. 最终，通过检查集合的数量来判断是否存在多个源（如果集合数量大于 1，则可能存在多源情况）。

### 3. 获取所有可行路径（使用 f 算法及 dfs 结合，且带有观光模式）
f 算法结合深度优先搜索（DFS）来找出从起点到终点的所有可行路径。在观光模式下，可能会考虑一些额外的因素，如路径的风景评分等。具体步骤如下：
1. 从起点开始，使用 DFS 遍历图的节点。
2. 在遍历过程中，记录已经访问过的节点，避免重复访问。
3. 当到达终点时，将当前路径记录下来作为一条可行路径。
4. 回溯到上一个节点，继续探索其他可能的路径，直到所有可能的路径都被探索完。

### 4. 单源中具体两点之间的路径优化（使用 A*算法）
A*算法用于在单源路径搜索的基础上，找到特定两个节点之间的最优路径。A*算法结合了当前节点到起点的实际距离和估计到终点的距离（启发式函数）来选择下一个要探索的节点。其核心步骤如下：
1. 初始化起点的相关信息，包括 g 值（实际距离）、h 值（估计距离）和 f 值（g + h）。
2. 将起点加入开放列表，不断从开放列表中选择 f 值最小的节点进行扩展。
3. 对于扩展的节点，更新其邻居节点的 g、h、f 值，并将邻居节点加入开放列表（如果不在开放列表或新的路径更优）。
4. 当终点被加入开放列表时，通过回溯找到从起点到终点的最优路径。

### 5. 不经过某些节点的路径规划
在上述算法的基础上，增加对不经过某些特定节点（如拥挤路段对应的路口节点）的限制。在算法执行过程中，当遇到这些被禁止的节点时，直接跳过不进行探索，从而得到满足条件的路径。

### 6. 字典树的应用
引入字典树（Trie 树）数据结构，主要用于快速查找和匹配某些特定的字符串或标识符。例如，在处理节点名称或路径相关的字符串信息时，字典树可以大大提高查询效率，减少时间复杂度。

## 三、代码结构与组织
项目代码主要分为以下几个模块：
1. **图数据结构模块**：负责图的构建、节点和边的表示等操作。
2. **算法模块**：包含上述各种算法的实现代码，每个算法对应一个独立的函数或类。
3. **数据处理模块**：用于读取输入数据（如节点信息、边的信息等），并进行必要的预处理。
4. **字典树模块**：实现字典树的相关操作，如插入、查询等。

## 四、使用说明
1. 安装必要的依赖库（请根据实际项目依赖补充）。
2. 运行主程序，按照提示输入相关参数，如起点、终点、不经过的节点等。
3. 程序将输出满足条件的路径信息及相关结果。
